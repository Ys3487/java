## 一 面向对象开始
## 二 构造函数
构造函数用来给对象的属性进行初始化。  
构造函数示例：
```java
class Person {
    String name;
    int age;
    Person() {
        name = "zs";
        age = 13;
        System.out.println("构造方法");
    }
}


public class Test {
    public static void main(String[] args) {
        Person p = new Person();                //创建对象时候输出"构造方法"
        System.out.println(p.name);             //输出13
    }
}

```
构造函数特点：
- 构造方法方法名与类名相同（大小写也一致）
- 构造方法没有返回值（也没有void）
- 构造方法不能被实例调用
- 如果类没有给出构造方法，那么系统默认会给一个无参的构造
- 如果类拥有手动书写的构造方法，那么系统不会给默认的无参构造，此时如果要使用无参构造，需要自己手动给出，推荐自己给出无参构造
上述案例中，数据被绑死了，没有扩展性,且对象的属性应该是私有的：
```java
class Person {
    private String name;
    private int age;
    Person(){
        System.out.println("空参构造");
    }
    Person(String name, int age) {
        this.name = name;
        this.age = age;
        System.out.println("有参构造");
    }
    void setName(String name) {
        this.name = name;
    }
    void setAge(int age) {
        this.age = age;
    }

    String getName() {
        return name;
    }
    int getAge() {
        return age;
    }
}


public class Test {
    public static void main(String[] args) {
        Person p = new Person();   //输出 无参构造
        p.setName("lisi");
        p.setAge(13);
        System.out.println(p.getName());
    }
}

```
注意：在上述案例中，我们用空参构造创建了对象，并使用setName方法来赋值，也可以直接使用new Person("lisi",16)
## 三 对象的创建步骤
- 1-.class文件加载进内存
- 2-声明一个该类（Person）类型的引用p
- 3-在堆内存创建一个对象
- 4-给对象中的属性初始化默认值
- 5-给对象中的属性进行显式初始化
- 6-构造方法进栈，堆对象中的属性赋值，构造方法弹栈
- 7-将对象的地址赋值给p
## 四 static
static修饰的数据随着类的加载而加载，自然就优先于对象的存在，且被类的所有对象共享，使用类名来调用。
```java
Person {
    static country = "中国";
}

System.out.println(Person.country);
```
注意：
- 非静态的方法，可以访问所有属性
- 静态方法只能访问静态属性
```
静态的变量，我们常称之为类变量，存储与方法区的静态区，随着类的加载而架子啊，消失而消失
成员变量属于对象，常称为实例变量，存储与堆内存，随着对象的消失而消失
静态变量可以通过类名，对象调用，一般使用类名调用
```
## 五 继承
```java

```
注意：
- Java只支持单一继承（只能继承自一个父类），
- 类可以被多个，多层类所继承
- 私有成员不可以被继承
- 就近原则：类的属性以就近的类为准（如果类本身没有该属性，查找父类，依次类推，如果最后还没有，则出错）
```java
class Person {
    String name = "lisi";
    Person() {

    }
}

class Student extends Person {
    String name = "zs";
    void show() {
        System.out.println(super.name);
    }
}

public class Test {
    public static void main(String[] args) {

        Student s = new Student();
        System.out.println(s.name);     //zs
        s.show();           //lisi

    }
}

```
方法：
- 重写：子类的方法和父类方法完全一样
- 重载：子类中的方法和父类方法名称一样，但是参数不一样（个数，类型，顺序不一样）
重写后的方法，子类实例只会调用子类自己的方法
重载后的方法，子类实例调用符合规则的方法
## 六 抽象类
abstract用修饰类和方法，作为抽象类，抽象方法
```java
//猫狗同属动物，但是在动物类中，我们无法书写其方法体
abstract class Animal {
    public abstract void eat();
}

class Cat extends Animal{
    public void eat() {
        System.out.println("猫吃鱼");
    }
}

class Dog {
    public void eat() {
        System.out.println("狗吃骨头");
    }
}
```
## 七 多态
多态的现象：事物存在多种形态  
多态的前提：
- 有继承关系
- 有方法重写
- 父类引用指向子类对象
```java
class Animal {
    public void eat() {
        System.out.println("动物吃..");
    };
    public static void run() {
        System.out.println("动物跑...");
    }
}

class Cat extends Animal{
    public void eat() {
        System.out.println("猫吃鱼");
    }
    public static void run() {
        System.out.println("猫奔跑...");
    }
}

class Test {
    public static void main(String[] args) {
        Animal c = new Cat();   //注意：编译看左边，运行看右边
        c.eat();            //父类引用指向子类对象，输出 猫吃鱼
        c.run();            //其实仍然是类名调用，输出 动物跑
    }
}
``
